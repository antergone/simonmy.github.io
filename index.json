[{"categories":["LeetCode"],"content":" https://leetcode.com/problems/longest-substring-without-repeating-characters/ impl Solution { pub fn length_of_longest_substring(s: String) -\u003e i32 { use std::cmp::max; use std::collections::HashMap; let mut m = HashMap::new(); let mut ans = 0; let mut before = -1; let mut current = 0; for c in s.chars() { if let Some(last) = m.insert(c, current) { before = max(before, last); } ans = max(ans, current - before); current += 1; } ans } } pub struct Solution; #[cfg(test)] mod tests { use crate::solutions::p0003_longest_substring_without_repeating_characters::Solution; #[test] fn test() { // let c = 'c' as usize; // println!(\"{}\", c) let length = Solution::length_of_longest_substring(\"pwwkew\".to_string()); println!(\"{}\", length) } } ","date":"2022-05-21 02:30","objectID":"/posts/leetcode/longest-substring-without-repeating-characters/:0:0","tags":null,"title":"3. Longest Substring Without Repeating Characters","uri":"/posts/leetcode/longest-substring-without-repeating-characters/"},{"categories":["LeetCode"],"content":" https://leetcode.com/problems/reverse-linked-list/ ","date":"2022-05-20 14:30","objectID":"/posts/leetcode/reverse-linked-list/:0:0","tags":null,"title":"206. Reverse Linked List","uri":"/posts/leetcode/reverse-linked-list/"},{"categories":["LeetCode"],"content":"Iterative use crate::data_struct::linked_list::ListNode; impl Solution { pub fn reverse_list(head: Option\u003cBox\u003cListNode\u003e\u003e) -\u003e Option\u003cBox\u003cListNode\u003e\u003e { let mut curr = head; let mut next = None; while let Some(mut inner) = curr { curr = inner.next.take(); inner.next = next; next = Some(inner); } next } } pub struct Solution; #[cfg(test)] mod tests { use crate::data_struct::linked_list::to_list; use crate::solutions::p0206_reverse_linked_list::Solution; #[test] fn test() { let l1 = vec![2, 7, 11, 15]; let res = Solution::reverse_list(to_list(l1)); println!(\"{:?}\", res) } } ","date":"2022-05-20 14:30","objectID":"/posts/leetcode/reverse-linked-list/:1:0","tags":null,"title":"206. Reverse Linked List","uri":"/posts/leetcode/reverse-linked-list/"},{"categories":["LeetCode"],"content":"Recursive use crate::data_struct::linked_list::ListNode; impl Solution { pub fn reverse_list(head: Option\u003cBox\u003cListNode\u003e\u003e) -\u003e Option\u003cBox\u003cListNode\u003e\u003e { Solution::reverse(None, head) } fn reverse(prev: Option\u003cBox\u003cListNode\u003e\u003e, head: Option\u003cBox\u003cListNode\u003e\u003e) -\u003e Option\u003cBox\u003cListNode\u003e\u003e { let mut cur = head; let mut next = None; if cur.is_some() { let mut n = cur.take().unwrap(); next = n.next.take(); n.next = prev; Solution::reverse(Some(n), next) } else { prev } } } pub struct Solution; #[cfg(test)] mod tests { use crate::data_struct::linked_list::to_list; use crate::solutions::p0206_reverse_linked_list::Solution; #[test] fn test() { let l1 = vec![2, 7, 11, 15]; let res = Solution::reverse_list(to_list(l1)); println!(\"{:?}\", res) } } ","date":"2022-05-20 14:30","objectID":"/posts/leetcode/reverse-linked-list/:2:0","tags":null,"title":"206. Reverse Linked List","uri":"/posts/leetcode/reverse-linked-list/"},{"categories":["LeetCode"],"content":" https://leetcode.com/problems/add-two-numbers/ use crate::data_struct::linked_list::ListNode; impl Solution { pub fn add_two_numbers( l1: Option\u003cBox\u003cListNode\u003e\u003e, l2: Option\u003cBox\u003cListNode\u003e\u003e, ) -\u003e Option\u003cBox\u003cListNode\u003e\u003e { let mut dummy = Box::new(ListNode::new(0)); let mut l1 = l1.as_ref(); let mut l2 = l2.as_ref(); let mut current = dummy.as_mut(); let mut carry = 0; while l1.is_some() || l2.is_some() || carry != 0 { let l1_value = l1.map_or(0, |n| n.val); let l2_value = l2.map_or(0, |n| n.val); l1 = l1.and_then(|n| n.next.as_ref()); l2 = l2.and_then(|n| n.next.as_ref()); let sum = carry + l1_value + l2_value; let current_value; if sum \u003e 9 { current_value = sum - 10; carry = 1; } else { carry = 0; current_value = sum; } current.next = Some(Box::new(ListNode::new(current_value))); current = current.next.as_mut().unwrap().as_mut(); } return dummy.next; } } pub struct Solution; #[cfg(test)] mod tests { use crate::{solutions::p0002_add_two_numbers::Solution, data_struct::linked_list::ListNode}; use crate::data_struct::linked_list::to_list; #[test] fn test() { assert_eq!( to_list(vec![7, 0, 8]), Solution::add_two_numbers(to_list(vec![2, 4, 3]), to_list(vec![5, 6, 4])) ); } } ","date":"2022-05-20 14:10","objectID":"/posts/leetcode/add-two-numbers/:0:0","tags":null,"title":"2. Add Two Numbers","uri":"/posts/leetcode/add-two-numbers/"},{"categories":["LeetCode"],"content":" LeetCode: https://leetcode.com/problems/two-sum/ impl Solution { pub fn two_sum(nums: Vec\u003ci32\u003e, target: i32) -\u003e Vec\u003ci32\u003e { let mut result_map: HashMap\u003ci32, i32\u003e = HashMap::new(); for (idx, val) in nums.iter().enumerate() { match result_map.get(\u0026(target - *val)) { Some(\u0026idx2) =\u003e return vec![idx2, idx as i32], None =\u003e result_map.insert(*val, idx as i32), }; } return vec![]; } } pub struct Solution; #[cfg(test)] mod tests { use crate::solutions::p0001_two_sum::Solution; #[test] fn test() { let l1 = vec![2, 7, 11, 15]; let res = Solution::two_sum(l1, 9); println!(\"{:?}\", res) } } ","date":"2022-05-08 18:00","objectID":"/posts/leetcode/two-sum/:0:0","tags":null,"title":"1. Two Sum","uri":"/posts/leetcode/two-sum/"},{"categories":["杂技浅尝"],"content":"We’ve created a script that will change any commits that previously had the old email address in its author or committer fields to use the correct name and email address. Note: Running this script rewrites history for all repository collaborators. After completing these steps, any person with forks or clones must fetch the rewritten history and rebase any local changes into the rewritten history. Before running this script, you’ll need: The old email address that appears in the author/committer fields that you want to change The correct name and email address that you would like such commits to be attributed to Open Terminal. Create a fresh, bare clone of your repository: git clone --bare https://github.com/user/repo.git cd repo.git Copy and paste the script, replacing the following variables based on the information you gathered: OLD_EMAIL CORRECT_NAME CORRECT_EMAIL #!/bin/sh git filter-branch --env-filter ' OLD_EMAIL=\"your-old-email@example.com\" CORRECT_NAME=\"Your Correct Name\" CORRECT_EMAIL=\"your-correct-email@example.com\" if [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ] then export GIT_COMMITTER_NAME=\"$CORRECT_NAME\" export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\" fi if [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ] then export GIT_AUTHOR_NAME=\"$CORRECT_NAME\" export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\" fi ' --tag-name-filter cat -- --branches --tags Press Enter to run the script. Review the new Git history for errors. Push the corrected history to GitHub: git push --force --tags origin 'refs/heads/*' Clean up the temporary clone: cd .. rm -rf repo.git ","date":"2022-05-08 18:00","objectID":"/posts/changing-the-git-history-of-your-repository-using-a-script/:0:0","tags":null,"title":"Changing the Git history of your repository using a script","uri":"/posts/changing-the-git-history-of-your-repository-using-a-script/"},{"categories":["杂技浅尝"],"content":"现象 近期遇到了一个非常诡异的事情，在MacOS上打的tar包，在linux上解压多出了一些 ._ 开头的隐藏文件。 ","date":"2021-06-25 22:56","objectID":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/:1:0","tags":null,"title":"Mac使用tar命令打包多出隐藏文件","uri":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"},{"categories":["杂技浅尝"],"content":"问题排查 我们来看下这个目录的内容， 然后我们来打包这个目录并MacOS查看压缩包的内容： 接下来我们把这个文件上传到linux服务器上，再查看这个压缩包的内容： 此时发现多了一个隐藏文件，那么问题来了，为什么会多？有程序读取这个文件就会出现异常！ ","date":"2021-06-25 22:56","objectID":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/:2:0","tags":null,"title":"Mac使用tar命令打包多出隐藏文件","uri":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"},{"categories":["杂技浅尝"],"content":"问题原因 经过排查，发现 MacOS 上的tar，和linux的tar竟然不止同一个系列！ MacOS是将tar命令link到bsdtar Linux是原生的GNU tar命令 发现了问题，就方便寻找解决方案。翻了翻bsdtar的文档(man手册也行) 手册中有非常明确的提示，这个是MacOS特有的，用于存储一些MacOS中文件特殊的属性。 ","date":"2021-06-25 22:56","objectID":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/:3:0","tags":null,"title":"Mac使用tar命令打包多出隐藏文件","uri":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"},{"categories":["杂技浅尝"],"content":"问题验证 查看文件的特殊属性？ mac上使用gnu tar查看是否也会有隐藏文件？ 如图所示，确实与描述一致，使用xattr看到了扩展属性，使用gun tar也看到了隐藏文件 ","date":"2021-06-25 22:56","objectID":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/:3:1","tags":null,"title":"Mac使用tar命令打包多出隐藏文件","uri":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"},{"categories":["杂技浅尝"],"content":"解决方案 ","date":"2021-06-25 22:56","objectID":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/:4:0","tags":null,"title":"Mac使用tar命令打包多出隐藏文件","uri":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"},{"categories":["杂技浅尝"],"content":"方案一 使用COPYFILE_DISABLE=1参数 COPYFILE_DISABLE=1 tar -zcvf junit.tar.gz junit-4.13.jar ","date":"2021-06-25 22:56","objectID":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/:4:1","tags":null,"title":"Mac使用tar命令打包多出隐藏文件","uri":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"},{"categories":["杂技浅尝"],"content":"方案二 使用 –no-mac-metadata tar --no-mac-metadata -zcvf junit.tar.gz junit-4.13.jar ","date":"2021-06-25 22:56","objectID":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/:4:2","tags":null,"title":"Mac使用tar命令打包多出隐藏文件","uri":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"},{"categories":["杂技浅尝"],"content":"方案三 使用gtar打包 通过homebrew安装guntar ( https://formulae.brew.sh/formula/gnu-tar ) 使用gtar进行打包 ","date":"2021-06-25 22:56","objectID":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/:4:3","tags":null,"title":"Mac使用tar命令打包多出隐藏文件","uri":"/posts/mac%E4%BD%BF%E7%94%A8tar%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%A4%9A%E5%87%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6/"},{"categories":["杂技浅尝"],"content":"用过阿里云服务器（ECS、轻量应用服务器）的人应该都知道，阿里云提供的系统镜像里预装了它的各种监控服务。 这些监控服务的存在使得人们可以直接在控制台看到当前系统的状态，某种程度上来说确实方便了服务器的管理。但是对于我们这种“爱折腾党”，基本没有用到这些服务的时候，而且天天被这些监控盯着还总有种被偷窥的感觉。 所以在这里介绍一下怎么卸载阿里云服务器上的各种监控服务。 ","date":"2020-02-21 18:04","objectID":"/posts/uninstall-monitoring-services-on-alibaba-cloud/:0:0","tags":null,"title":"彻底卸载阿里云服务器上的各种监控服务","uri":"/posts/uninstall-monitoring-services-on-alibaba-cloud/"},{"categories":["杂技浅尝"],"content":"卸载云盾（安骑士） 在官方文档页面只介绍了怎么在控制台去卸载，手动卸载的操作步骤需要提交工单获取，不是很方便。 在这里介绍一种用脚本手动卸载的方法（其实用的也是官方提供的两个脚本），执行以下命令即可。 wget http://update.aegis.aliyun.com/download/uninstall.sh \u0026\u0026 chmod +x uninstall.sh \u0026\u0026./uninstall.sh wget http://update.aegis.aliyun.com/download/quartz_uninstall.sh \u0026\u0026 chmod +x quartz_uninstall.sh \u0026\u0026 ./quartz_uninstall.sh 上面的脚本运行完之后可能还会有一些文件/文件夹残留，所以我们手动删除一下（如果提示文件不存在就不用管了） sudo rm -r /usr/local/aegis sudo rm /usr/sbin/aliyun-service sudo rm /lib/systemd/system/aliyun.service ","date":"2020-02-21 18:04","objectID":"/posts/uninstall-monitoring-services-on-alibaba-cloud/:1:0","tags":null,"title":"彻底卸载阿里云服务器上的各种监控服务","uri":"/posts/uninstall-monitoring-services-on-alibaba-cloud/"},{"categories":["杂技浅尝"],"content":"卸载云监控（Cloudmonitor） 云监控有 Java 版本和 Go 语言版本两种，可以根据其安装目录 /usr/local/cloudmonitor/ 下的文件名判断你的服务器上装的具体是哪一种。下面分别介绍两个版本的卸载方法。 ","date":"2020-02-21 18:04","objectID":"/posts/uninstall-monitoring-services-on-alibaba-cloud/:2:0","tags":null,"title":"彻底卸载阿里云服务器上的各种监控服务","uri":"/posts/uninstall-monitoring-services-on-alibaba-cloud/"},{"categories":["杂技浅尝"],"content":"卸载云监控 Java 版 # 停止 /usr/local/cloudmonitor/wrapper/bin/cloudmonitor.sh stop # 卸载 /usr/local/cloudmonitor/wrapper/bin/cloudmonitor.sh remove \u0026\u0026 \\ rm -rf /usr/local/cloudmonitor 附上官方文档页面链接：https://help.aliyun.com/knowledge_detail/38859.html ","date":"2020-02-21 18:04","objectID":"/posts/uninstall-monitoring-services-on-alibaba-cloud/:2:1","tags":null,"title":"彻底卸载阿里云服务器上的各种监控服务","uri":"/posts/uninstall-monitoring-services-on-alibaba-cloud/"},{"categories":["杂技浅尝"],"content":"卸载云监控 Go 语言版 云监控 Go 语言版的可执行文件名为 CmsGoAgent.linux-${ARCH} ，其中的 ARCH 根据 Linux 架构的不同，分为 amd64 和 386 ，可以在其安装目录 /usr/local/cloudmonitor/ 下找到具体的文件名。 为了方便表述，下面的命令中也使用 ${ARCH} 替代文件名中的系统架构部分。要能够直接复制下面的命令行去执行的话，可以先设置一下临时环境变量（相当于后面输入命令中的 ${ARCH} 会被自动替换成我们在这里设置的值） # 64 位系统 export ARCH=amd64 # 32 位系统 export ARCH=386 或者的话你也可以在找到具体的文件名后自行替换。下面是卸载相关的一些命令： # 从系统服务中移除 /usr/local/cloudmonitor/CmsGoAgent.linux-${ARCH} uninstall # 停止 /usr/local/cloudmonitor/CmsGoAgent.linux-${ARCH} stop # 卸载 /usr/local/cloudmonitor/CmsGoAgent.linux-${ARCH} stop \u0026\u0026 \\ /usr/local/cloudmonitor/CmsGoAgent.linux-${ARCH} uninstall \u0026\u0026 \\ rm -rf /usr/local/cloudmonitor 附上官方文档页面链接：https://help.aliyun.com/document_detail/97929.html ","date":"2020-02-21 18:04","objectID":"/posts/uninstall-monitoring-services-on-alibaba-cloud/:2:2","tags":null,"title":"彻底卸载阿里云服务器上的各种监控服务","uri":"/posts/uninstall-monitoring-services-on-alibaba-cloud/"},{"categories":["杂技浅尝"],"content":"Linux Linux系统直接用现成的工具，没有什么花头。推荐几个好用的工具： ","date":"2020-02-09 06:39","objectID":"/posts/make-a-usb-boot-disk-in-mac-os/:1:0","tags":null,"title":"MacOS下制作启动盘","uri":"/posts/make-a-usb-boot-disk-in-mac-os/"},{"categories":["杂技浅尝"],"content":"Etcher 直接下载安装使用，UI操作就不详细介绍了 下载地址：https://www.balena.io/etcher/ ","date":"2020-02-09 06:39","objectID":"/posts/make-a-usb-boot-disk-in-mac-os/:1:1","tags":null,"title":"MacOS下制作启动盘","uri":"/posts/make-a-usb-boot-disk-in-mac-os/"},{"categories":["杂技浅尝"],"content":"UNetbootin 直接下载安装使用，UI操作就不详细介绍了 下载地址：https://unetbootin.github.io/ ","date":"2020-02-09 06:39","objectID":"/posts/make-a-usb-boot-disk-in-mac-os/:1:2","tags":null,"title":"MacOS下制作启动盘","uri":"/posts/make-a-usb-boot-disk-in-mac-os/"},{"categories":["杂技浅尝"],"content":"dd命令 查U盘的标识 simon@antergone:~$diskutil list /dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *251.0 GB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_APFS Container disk1 250.8 GB disk0s2 /dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +250.8 GB disk1 Physical Store disk0s2 1: APFS Volume Macintosh HD 216.1 GB disk1s1 2: APFS Volume Preboot 22.1 MB disk1s2 3: APFS Volume Recovery 509.8 MB disk1s3 4: APFS Volume VM 3.2 GB disk1s4 /dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *15.9 GB disk2 1: Windows_FAT_32 15.9 GB disk2s4 卸载U盘挂载 simon@antergone:~$diskutil unmountDisk /dev/disk2 Unmount of all volumes on disk2 was successful 写入镜像 simon@antergone:~$sudo dd if=/Users/simon/CentOS-7-x86_64-DVD-1908.iso of=/dev/disk2 bs=1m Password: 输入密码 ","date":"2020-02-09 06:39","objectID":"/posts/make-a-usb-boot-disk-in-mac-os/:1:3","tags":null,"title":"MacOS下制作启动盘","uri":"/posts/make-a-usb-boot-disk-in-mac-os/"},{"categories":["杂技浅尝"],"content":"Windows ","date":"2020-02-09 06:39","objectID":"/posts/make-a-usb-boot-disk-in-mac-os/:2:0","tags":null,"title":"MacOS下制作启动盘","uri":"/posts/make-a-usb-boot-disk-in-mac-os/"},{"categories":["杂技浅尝"],"content":"查U盘的标识 simon@antergone:~$diskutil list /dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *251.0 GB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_APFS Container disk1 250.8 GB disk0s2 /dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +250.8 GB disk1 Physical Store disk0s2 1: APFS Volume Macintosh HD 216.1 GB disk1s1 2: APFS Volume Preboot 22.1 MB disk1s2 3: APFS Volume Recovery 509.8 MB disk1s3 4: APFS Volume VM 3.2 GB disk1s4 /dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *15.9 GB disk2 1: Windows_FAT_32 15.9 GB disk2s4 ","date":"2020-02-09 06:39","objectID":"/posts/make-a-usb-boot-disk-in-mac-os/:2:1","tags":null,"title":"MacOS下制作启动盘","uri":"/posts/make-a-usb-boot-disk-in-mac-os/"},{"categories":["杂技浅尝"],"content":"重命名、格式化U盘 simon@antergone:~$diskutil eraseDisk MS-DOS \"BOOTDISK\" MBR disk2 Tips: 注意这里的disk2，是上一步查询出来的，可能因个人而异 ","date":"2020-02-09 06:39","objectID":"/posts/make-a-usb-boot-disk-in-mac-os/:2:2","tags":null,"title":"MacOS下制作启动盘","uri":"/posts/make-a-usb-boot-disk-in-mac-os/"},{"categories":["杂技浅尝"],"content":"挂载iso文件 hdiutil attach /Users/simon/Windows.iso ","date":"2020-02-09 06:39","objectID":"/posts/make-a-usb-boot-disk-in-mac-os/:2:3","tags":null,"title":"MacOS下制作启动盘","uri":"/posts/make-a-usb-boot-disk-in-mac-os/"},{"categories":["杂技浅尝"],"content":"写入U盘 cp -rp /Volumes/Windows-xxxxx/* /Volumes/BOOTDISK/ Tips: 注意这里 Windows-xxxx 是具体挂载的名字，别忘了后面有个通配* ","date":"2020-02-09 06:39","objectID":"/posts/make-a-usb-boot-disk-in-mac-os/:2:4","tags":null,"title":"MacOS下制作启动盘","uri":"/posts/make-a-usb-boot-disk-in-mac-os/"},{"categories":["杂技浅尝"],"content":"写在最后 这里我不建议大家直接写入Windows镜像，可以尝试写入PE系统的镜像，维护起来更方便。在这里也推荐一个我用了8年左右的Windows PE工具: 杏雨梨云启动维护系统。平时可以用Windows系统导出iso版本的PE系统镜像，将上面的Windows.iso换成他导出的镜像写入U盘即可。 ","date":"2020-02-09 06:39","objectID":"/posts/make-a-usb-boot-disk-in-mac-os/:2:5","tags":null,"title":"MacOS下制作启动盘","uri":"/posts/make-a-usb-boot-disk-in-mac-os/"},{"categories":["杂技浅尝"],"content":"背景现象 这里就不再多说了，国行的iPhone只能使用FaceTime Video，无法使用FaceTime Audio。通俗的来说，就是国内买的iPhone，FaceTime只能发视频接视频，不允许发语音接语音。 具体原因我也不知道是什么，我也没有精力去深究，毕竟目标是解决问题。不要尝试跟Apple客服和运营商沟通，两边疯狂踢皮球甩锅。 ","date":"2020-01-22 15:35","objectID":"/posts/%E5%9B%BD%E8%A1%8Ciphone%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8facetime-audio/:1:0","tags":null,"title":"国行iPhone用户如何使用FaceTime Audio","uri":"/posts/%E5%9B%BD%E8%A1%8Ciphone%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8facetime-audio/"},{"categories":["杂技浅尝"],"content":"解决目标 可以接听他人发起的FaceTime Audio 可以主动向他人发起FaceTime Audio 对方是FaceTime Audio可用的iPhone设备(美版，港版等)，可接听 对方是国行iPhone设备，用下面的方法破解启用FaceTime Audio，可接听 对方是iPad用户(我只有wifi版本，其他版本不知道)，可接听 如果对方是国行，未越狱或未破解，无法接听。 ","date":"2020-01-22 15:35","objectID":"/posts/%E5%9B%BD%E8%A1%8Ciphone%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8facetime-audio/:2:0","tags":null,"title":"国行iPhone用户如何使用FaceTime Audio","uri":"/posts/%E5%9B%BD%E8%A1%8Ciphone%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8facetime-audio/"},{"categories":["杂技浅尝"],"content":"解决方案 ","date":"2020-01-22 15:35","objectID":"/posts/%E5%9B%BD%E8%A1%8Ciphone%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8facetime-audio/:3:0","tags":null,"title":"国行iPhone用户如何使用FaceTime Audio","uri":"/posts/%E5%9B%BD%E8%A1%8Ciphone%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8facetime-audio/"},{"categories":["杂技浅尝"],"content":"必要条件 Jailbreak, 也就是越狱。因为我手贱刷到了iOS13，所以用的是checkra1n( https://checkra.in/ )，具体操作步骤官网写的很清楚。 这里要提醒一下大家：这个方案越狱后重启是要重新越狱的。 ","date":"2020-01-22 15:35","objectID":"/posts/%E5%9B%BD%E8%A1%8Ciphone%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8facetime-audio/:3:1","tags":null,"title":"国行iPhone用户如何使用FaceTime Audio","uri":"/posts/%E5%9B%BD%E8%A1%8Ciphone%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8facetime-audio/"},{"categories":["杂技浅尝"],"content":"不完美的轻量级解决方案(只能接听) 之前国内的一个大佬 songchenwen 出过一个插件叫做FaceTime Audio Enabler。Bigboss源里面已经收录了他的这个插件，直接安装即可，iOS 13亲测可接听。具体的安装步骤移步他的博客链接。 本来我想基于他的这个解决方案来适配iOS 12以后的版本，但是尝试了很多方法都没有完美解决接听和拨打，只实现了接听，最终以失败而告终。在这期间感谢 songchenwen 给的帮助和支持。 如果有人对这个方案有兴趣，可以继续研究，Github仓库地址 ，如果可以成功解决拨打问题，可以往他的仓库提PR。由于Theos升级，他的源码现在已经无法在最新版本的Theos上编译，我已经将代码适配到了Theos最新版本，也适配了接听功能，但是拨打功能还是没有实现。 在这里，我想提一句百度上能搜到的资料，基本上都是出自于他的和这个方案。所谓的补两个文件，只是把他打的包里面的两个核心文件提取出来，复制到手机里面罢了。 ","date":"2020-01-22 15:35","objectID":"/posts/%E5%9B%BD%E8%A1%8Ciphone%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8facetime-audio/:3:2","tags":null,"title":"国行iPhone用户如何使用FaceTime Audio","uri":"/posts/%E5%9B%BD%E8%A1%8Ciphone%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8facetime-audio/"},{"categories":["杂技浅尝"],"content":"完美解决方案 安装插件Globalize, 一定要注意版本 \u003e=0.2.5 安装步骤： 在Cydia内添加软件源：https://parrotgeek.com/repo 搜索并安装Globalize，安装0.2.5版本。 安装完成后，用ssh连接手机，执行 ldrestart 命令 你也可以直接下载 deb包 ，手动安装。安装完成后，用ssh连接手机，执行 ldrestart 命令 对该解决方案想详细了解原理的，可以直接去 Github仓库 探究。 方案出处：https://www.reddit.com/r/jailbreak/comments/du5b9q/request_facetime_audio_for_chinese_iphone_models/ ","date":"2020-01-22 15:35","objectID":"/posts/%E5%9B%BD%E8%A1%8Ciphone%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8facetime-audio/:3:3","tags":null,"title":"国行iPhone用户如何使用FaceTime Audio","uri":"/posts/%E5%9B%BD%E8%A1%8Ciphone%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8facetime-audio/"},{"categories":["杂技浅尝"],"content":"Docker默认使用的网桥 docker0 的网段是 172.17.0.1，正好和公司网络冲突。 网上的资料也一如既往的狗血，在这里记录下自己的配置。 以下步骤自测过得版本: 1.12.x, 1.13.1 其他版本，如果有需要可以自行测试，应该差不太多。 ","date":"2017-08-24 01:16","objectID":"/posts/how-to-change-the-docker-default-subnet-ip-address/:0:0","tags":null,"title":"修改Docker0的IP地址","uri":"/posts/how-to-change-the-docker-default-subnet-ip-address/"},{"categories":["杂技浅尝"],"content":"第一步 删除原有配置 sudo service docker stop sudo ip link set dev docker0 down sudo brctl delbr docker0 sudo iptables -t nat -F POSTROUTING ","date":"2017-08-24 01:16","objectID":"/posts/how-to-change-the-docker-default-subnet-ip-address/:1:0","tags":null,"title":"修改Docker0的IP地址","uri":"/posts/how-to-change-the-docker-default-subnet-ip-address/"},{"categories":["杂技浅尝"],"content":"第二步 创建新的网桥 sudo brctl addbr docker0 sudo ip addr add 192.168.200.1/24 dev docker0 sudo ip link set dev docker0 up ","date":"2017-08-24 01:16","objectID":"/posts/how-to-change-the-docker-default-subnet-ip-address/:2:0","tags":null,"title":"修改Docker0的IP地址","uri":"/posts/how-to-change-the-docker-default-subnet-ip-address/"},{"categories":["杂技浅尝"],"content":"第三步 配置Docker的文件 注意： 这里是 增加下面的配置 vi /etc/docker/daemon.json { ... \"bip\": \"192.168.200.1/24\", ... } docker的配置现在都是用daemon.json了，不需要去设置DOCKER_OPTS, 所以网络上很多的资料早已 过时。 ","date":"2017-08-24 01:16","objectID":"/posts/how-to-change-the-docker-default-subnet-ip-address/:3:0","tags":null,"title":"修改Docker0的IP地址","uri":"/posts/how-to-change-the-docker-default-subnet-ip-address/"},{"categories":["杂技浅尝"],"content":"第四步 重启主机 sudo reboot ","date":"2017-08-24 01:16","objectID":"/posts/how-to-change-the-docker-default-subnet-ip-address/:4:0","tags":null,"title":"修改Docker0的IP地址","uri":"/posts/how-to-change-the-docker-default-subnet-ip-address/"},{"categories":["杂技浅尝"],"content":"前因 前些天因为工作需要在阿里云弄了一批VPC机器，刚开始是每个人都给了账号密码让其登录控制，又因为各种问题，收回了权限。 为了控制登录权限，所以启动了跳板机 （ http://www.jumpserver.org/ ） 后来又一个开发开始质疑，VPC其他的机器你可以防火墙禁止外界登录，那你跳板机最该要开一个ssh吧？如果这个机器的账号密码被知道了，那不是GG了 好吧，我就想到了这个坑办法。OTP，一次性密码~ 目的让登录的时不仅需要linux的账号密码，还需要一个动态的口令。 ","date":"2017-03-20 02:15","objectID":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/:1:0","tags":null,"title":"Linux 利用Google Authenticator实现ssh登录双因素认证","uri":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/"},{"categories":["杂技浅尝"],"content":"操作 ","date":"2017-03-20 02:15","objectID":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/:2:0","tags":null,"title":"Linux 利用Google Authenticator实现ssh登录双因素认证","uri":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/"},{"categories":["杂技浅尝"],"content":"手机软件下载 Google Authenticator iOS 下载地址 Android 下载地址 ","date":"2017-03-20 02:15","objectID":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/:2:1","tags":null,"title":"Linux 利用Google Authenticator实现ssh登录双因素认证","uri":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/"},{"categories":["杂技浅尝"],"content":"服务器安装chrony 安装这个的原因是因为Google的OTP算法其中有一个因素是时间，因此我们一定要保证时间的正确性 [root@localhost ~]# yum install -y chrony [root@localhost ~]# vim /etc/chrony.conf server 0.cn.pool.ntp.org server 1.cn.pool.ntp.org server 2.cn.pool.ntp.org server 3.cn.pool.ntp.org [root@localhost ~]# systemctl restart chronyd [root@localhost ~]# chronyc sources ","date":"2017-03-20 02:15","objectID":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/:2:2","tags":null,"title":"Linux 利用Google Authenticator实现ssh登录双因素认证","uri":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/"},{"categories":["杂技浅尝"],"content":"服务器安装Google Authenticator [root@localhost ~]# yum install -y git automake libtool pam-devel [root@localhost ~]# git clone https://github.com/google/google-authenticator-libpam.git [root@localhost ~]# cd google-authenticator-libpam/ [root@localhost google-authenticator-libpam]# ./bootstrap.sh [root@localhost google-authenticator-libpam]# ./configure [root@localhost google-authenticator-libpam]# make \u0026\u0026 make install [root@localhost google-authenticator-libpam]# google-authenticator [root@localhost google-authenticator-libpam]# cd ~ # 修改配置文件 [root@localhost ~]# vim /etc/pam.d/sshd auth required pam_google_authenticator.so no_increment_hotp [root@localhost ~]# vim /etc/ssh/sshd_config asswordAuthentication yes ChallengeResponseAuthentication yes UsePAM yes # 重启ssh服务 [root@localhost ~]# systemctl restart sshd # 生成令牌 [root@localhost ~]# google-authenticator Do you want authentication tokens to be time-based (y/n) y #你想做的认证令牌是基于时间的吗？ Warning: pasting the following URL into your browser exposes the OTP secret to Google: https://www.google.com/chart?chs=200x200\u0026chld=M|0\u0026cht=qr\u0026chl=otpauth://totp/root@localhost.localdomain%3Fsecret%3DN4HLEJOQHT27VCR6RX66WXB2SY%26issuer%3Dlocalhost.localdomain [这里会有一个很大的二维码] Your new secret key is: N4HLEJOQHT27VCR6RX66WXB2SY #这个key就是加密串，如果你有多个设备，需要把这个保存下，方便以后添加认证设备 Your verification code is 299695 #输入手机上Google Authenticator的code Your emergency scratch codes are: #下面这些key是紧急安全码，假如你的手机丢了，紧急登录用的。 44477086 92790948 29251218 26350870 30696065 Do you want me to update your \"/root/.google_authenticator\" file? (y/n) y #你希望我更新你的“/root/.google_authenticator”文件吗(y/n)？ Do you want to disallow multiple uses of the same authentication token? This restricts you to one login about every 30s, but it increases your chances to notice or even prevent man-in-the-middle attacks (y/n) y #你希望禁止多次使用同一个验证令牌吗?这限制你每次登录的时间大约是30秒， 但是这加大了发现或甚至防止中间人攻击的可能性(y/n)? By default, a new token is generated every 30 seconds by the mobile app. In order to compensate for possible time-skew between the client and the server, we allow an extra token before and after the current time. This allows for a time skew of up to 30 seconds between authentication server and client. If you experience problems with poor time synchronization, you can increase the window from its default size of 3 permitted codes (one previous code, the current code, the next code) to 17 permitted codes (the 8 previous codes, the current code, and the 8 next codes). This will permit for a time skew of up to 4 minutes between client and server. Do you want to do so? (y/n) y #默认情况下，令牌保持30秒有效;为了补偿客户机与服务器之间可能存在的时滞， 我们允许在当前时间前后有一个额外令牌。如果你在时间同步方面遇到了问题， 可以增加窗口从默认的3个可通过验证码增加到17个可通过验证码， 这将允许客户机与服务器之间的时差增加到4分钟。你希望这么做吗(y/n)? If the computer that you are logging into is not hardened against brute-force login attempts, you can enable rate-limiting for the authentication module. By default, this limits attackers to no more than 3 login attempts every 30s. Do you want to enable rate-limiting? (y/n) y #如果你登录的那台计算机没有经过固化，以防范运用蛮力的登录企图，可以对验证模块 启用尝试次数限制。默认情况下，这限制攻击者每30秒试图登录的次数只有3次。 你希望启用尝试次数限制吗(y/n)? ","date":"2017-03-20 02:15","objectID":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/:3:0","tags":null,"title":"Linux 利用Google Authenticator实现ssh登录双因素认证","uri":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/"},{"categories":["杂技浅尝"],"content":"登录验证 注意，第一次登录可能会出现登录失败的情况，查看日志信息显示错误如下： [root@localhost ~]# tail -n10 /var/log/secure ... Dec 31 09:42:46 localhost sshd[2393]: PAM unable to dlopen(/usr/lib64/security/pam_google_authenticator.so): /usr/lib64/security/pam_google_authenticator.so: cannot open shared object file: No such file or directory Dec 31 09:42:46 localhost sshd[2393]: PAM adding faulty module: /usr/lib64/security/pam_google_authenticator.so ... [root@localhost ~]# ln -sv /usr/local/lib/security/pam_google_authenticator.so /usr/lib64/security/pam_google_authenticator.so \"/usr/lib64/security/pam_google_authenticator.so\" -\u003e \"/usr/local/lib/security/pam_google_authenticator.so\" ","date":"2017-03-20 02:15","objectID":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/:4:0","tags":null,"title":"Linux 利用Google Authenticator实现ssh登录双因素认证","uri":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/"},{"categories":["杂技浅尝"],"content":"登录方法(SecureCRT) 一定要将这个放在第一个！ ","date":"2017-03-20 02:15","objectID":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/:4:1","tags":null,"title":"Linux 利用Google Authenticator实现ssh登录双因素认证","uri":"/posts/linux-%E5%88%A9%E7%94%A8google-authenticator%E5%AE%9E%E7%8E%B0ssh%E7%99%BB%E5%BD%95%E5%8F%8C%E5%9B%A0%E7%B4%A0%E8%AE%A4%E8%AF%81/"}]